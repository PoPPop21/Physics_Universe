# -*- coding: utf-8 -*-
"""Laboratorio3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ob8Unh6lED8VBC852eNjPLT31i7zGGVf

# Potencial en forma de V

El potencial considerado es:

$$
V(x) =
\begin{cases}
\infty, & x \leq x_0 \\
V_0 |x|, & x_0 < x < x_{N+1} \\
\infty, & x \geq x_{N+1}
\end{cases}
$$

donde:
- $ V_0 $ es un par√°metro que determina la pendiente del potencial.
- $ x_0 $ y $ x_{N+1} $ son los l√≠mites donde el potencial se hace infinito, asegurando confinamiento de la part√≠cula.

# M√©todo de Brentq üéÄ
Para el potencial en V que queremos resolver, la ecuaci√≥n de Schrodinger tiene como soluci√≥nla Ecuaci√≥n de Airy. En principio la ecuaci√≥n de Schrodinger es un problema de eigen-values, por lo que al obtener su soluci√≥n, las ra√≠ces de la ecuaci√≥n de airy vienen siendo los eigen-values de la ec de schrodinger (es decir, las energ√≠as permitidas), y las funciones de onda los eigen vectores.

---

## ¬øEn qu√© consiste el m√©todo Brentq? üéÑ
Se busca resolver una ecuaci√≥n no lineal de la forma:
$$
f(E) = 0
$$
donde $f(E)$ puede ser, por ejemplo, la condici√≥n de frontera de la ec de schrodinger (como $\psi(L;E)=0$. Es imposible resolverla anal√≠ticamente, as√≠ que usamos un m√©todo num√©rico de b√∫squeda de ra√≠ces.

### Teorema de Bolzano
El m√©todo se apoya en el teorema de bolzano:
- Si $f(a)$ y $f(b)$ tienen signos opuestos $(f(a)f(b)<0$, entonces existe al menos una ra√≠z en el intervalo [a, b].
- De manera que el c√≥digo antes de usar Brent: busca intervalos donde la funci√≥n cambia de signo.

## Brent üé®
Este m√©todo combina tres m√©todos:
1. Bisecci√≥n: divide el intervalo a la mitad, siempre converge (unicamente para el orden linel).
2. Secante : usa una recta secante entre dos puntos $(x_{0}, f(x_{0}))$ y $(x_{1}, f(x_{1}))$. Converge m√°s r√°pido (orden superlineal), aunque no siempre garantiza convergencia.
3. Interpolaci√≥n cuadr√°tica inversa: usa tres puntos y ajusta una par√°bola para estimar la ra√≠z, aumenta su rapidez si la funci√≥n es "suave".
"""

import numpy as np
import matplotlib.pyplot as plt
from ipywidgets import interact, FloatSlider
from scipy.optimize import brentq
import warnings
warnings.filterwarnings('ignore')

def numerov_step(psi_n, psi_nm1, k_n, k_nm1, k_np1, dx):
    """Un paso del m√©todo de Numerov"""
    factor = (2 * (1 - (5/12) * dx**2 * k_n) * psi_n - (1 + (1/12) * dx**2 * k_nm1) * psi_nm1) \
             / (1 + (1/12) * dx**2 * k_np1)
    return factor

def numerov_solve(E, x, dx, m, hbar, V):
    """Resuelve la ecuaci√≥n de Schr√∂dinger con el m√©todo de Numerov para energ√≠a E"""
    N = len(x)
    psi = np.zeros(N)

    # Definimos k^2 = 2m(E-V)/‚Ñè¬≤
    k2 = 2 * m * (E - V) / hbar**2

    # Condiciones iniciales (funci√≥n de onda debe ser 0 en los extremos)
    psi[0] = 0.0
    psi[1] = dx  # Peque√±o valor para iniciar

    for i in range(1, N-1):
        psi[i+1] = numerov_step(psi[i], psi[i-1], k2[i], k2[i-1], k2[i+1], dx)

    return psi

def boundary_condition(E, x, dx, m, hbar, V):
    """
    Funci√≥n que eval√∫a la condici√≥n de frontera.
    Debe ser cero para los valores propios de energ√≠a.
    """
    psi = numerov_solve(E, x, dx, m, hbar, V)
    return psi[-1]  # La funci√≥n de onda debe ser 0 en el extremo derecho

def find_energy_levels(x, dx, m, hbar, V, E_min, E_max, n_levels=10):
    """
    Encuentra los niveles de energ√≠a usando el m√©todo de b√∫squeda de ra√≠ces
    """
    energy_levels = []

    # Crear una grilla fina de energ√≠as para buscar cambios de signo
    E_search = np.linspace(E_min, E_max, 2000)
    boundary_vals = []

    print("Buscando niveles de energ√≠a...")

    for E in E_search:
        try:
            val = boundary_condition(E, x, dx, m, hbar, V)
            boundary_vals.append(val)
        except:
            boundary_vals.append(np.nan)

    boundary_vals = np.array(boundary_vals)

    # Buscar cambios de signo (ra√≠ces)
    for i in range(len(boundary_vals)-1):
        if (not np.isnan(boundary_vals[i]) and not np.isnan(boundary_vals[i+1]) and
            boundary_vals[i] * boundary_vals[i+1] < 0):

            try:
                # Usar el m√©todo de Brent para encontrar la ra√≠z exacta
                E_level = brentq(lambda E: boundary_condition(E, x, dx, m, hbar, V),
                               E_search[i], E_search[i+1], xtol=1e-12)
                energy_levels.append(E_level)

                if len(energy_levels) >= n_levels:
                    break

            except:
                continue

    return np.array(energy_levels)

# Par√°metros del sistema
L = 5e-10  # Tama√±o del sistema (m)
N = 2001   # N√∫mero de puntos
x = np.linspace(-L, L, N)
dx = x[1] - x[0]

# Constantes f√≠sicas
m_e = 9.109e-31  # Masa del electr√≥n (kg)
hbar = 1.055e-34  # Constante de Planck reducida (J¬∑s)

def update_plot(E_min_eV, E_max_eV, V0_eV):
    """Valroes actualizados por los ingresados por el usuario, estos son transformados a eV"""
    E_min = E_min_eV * 1.6e-19
    E_max = E_max_eV * 1.6e-19
    V0 = V0_eV * 1.6e-19
    V = V0 * np.abs(x) / L

    energy_levels = find_energy_levels(x, dx, m_e, hbar, V, E_min, E_max, n_levels=8)

    print(f"\nNiveles de energ√≠a encontrados: {len(energy_levels)}")
    for i, E in enumerate(energy_levels):
        print(f"E_{i+1} = {E/1.6e-19:.3f} eV")

    plt.figure(figsize=(10, 8))
    x_plot = x / L * 8

    V_plot = V / (V0_eV * 1.6e-19) * 6 # Scale V to V0_eV

    plt.plot(x_plot, V_plot, 'r-', linewidth=3, label='V(x)')

    colors = ['blue', 'green', 'orange', 'purple', 'brown', 'pink', 'gray', 'olive']

    for i, E in enumerate(energy_levels[:8]):
        E_plot = E / (V0_eV * 1.6e-19) * 6
        psi = numerov_solve(E, x, dx, m_e, hbar, V)
        psi_norm = psi / np.max(np.abs(psi))
        psi_scaled = psi_norm * 0.4 + E_plot
        color = colors[i] if i < len(colors) else 'black'
        plt.axhline(y=E_plot, color=color, linestyle='-', linewidth=1, alpha=0.8)
        plt.plot(x_plot, psi_scaled, color=color, linewidth=2)
        plt.text(8.2, E_plot, f'{E_plot:.3f}', fontsize=10,
                 verticalalignment='center', color='black')

    plt.xlim(-8, 8)
    plt.ylim(0, 7)
    plt.xlabel('', fontsize=12)
    plt.ylabel('V(x)', fontsize=14)
    plt.title('Niveles de energ√≠a y funciones de onda', fontsize=16, pad=20)

    plt.grid(True, color='gray', linestyle='-', linewidth=0.5, alpha=0.7)

    plt.xticks(np.arange(-8, 9, 2), fontsize=10)

    y_ticks = [0, 1, 2, 3, 4, 5, 6, 7]
    plt.yticks(y_ticks, fontsize=10)

    plt.tight_layout()
    plt.show()

# -- widgets --
interact(update_plot,
         E_min_eV=FloatSlider(value=0.01, min=0.001, max=10, step=0.01, description='E_min (eV):'),
         E_max_eV=FloatSlider(value=40, min=10, max=100, step=1, description='E_max (eV):'),
         V0_eV=FloatSlider(value=50, min=10, max=100, step=1, description='V0 (eV):'));
# Referencias: http://www.sc.ehu.es/sbweb/fisica3/cuantica/airy/airy.html

"""Referencias:
1. http://www.sc.ehu.es/sbweb/fisica3/cuantica/airy/airy.html
2. https://es.wikipedia.org/wiki/Funci√≥n_de_Airy

El potencial en forma de V es una funci√≥n que tiene par√°metros que determina la pendiente del potencial. Este tipo de potencial es caracter√≠stico de sistemas f√≠sicos donde la energ√≠a potencial crece linealmente con la distancia desde un punto de referencia, lo que se observa en diferentes contextos de la mec√°nica cu√°ntica y la f√≠sica cl√°sica.

## Caracter√≠sticas del potencial en forma de V
1. **Simetr√≠a**: El potencial es sim√©trico respecto al eje $x = 0$, lo que significa que la fuerza resultante es igual en magnitud pero opuesta en direcci√≥n para posiciones positivas y negativas.
2. **Crecimiento lineal**: A diferencia de un pozo de potencial cuadr√°tico (como el oscilador arm√≥nico), este potencial crece de manera lineal a medida que nos alejamos del origen.
3. **Energ√≠a y confinamiento**: Este potencial no posee paredes infinitas dentro de un intervalo finito como un **pozo de potencial infinito**, pero si se considera dentro de un dominio restringido $x_0 < x < x_{N+1}$, el sistema se comporta como una part√≠cula confinada.

## Importancia en f√≠sica cu√°ntica
El potencial en forma de V se usa en varios modelos f√≠sicos, tales como:
- La aproximaci√≥n al potencial de part√≠culas en campos externos lineales.
- Modelos de confinamiento en f√≠sica de part√≠culas.
- Aproximaciones a sistemas con fuerzas el√°sticas no lineales.

En mec√°nica cu√°ntica, resolver la ecuaci√≥n de Schr√∂dinger para este potencial implica encontrar las funciones de onda $\psi(x)$ y los valores de energ√≠a permitidos $E_n$. Una manera num√©rica de abordar esta soluci√≥n es usando el **m√©todo de Numerov**, que permite obtener soluciones precisas a ecuaciones diferenciales de segundo orden como la ecuaci√≥n de Schr√∂dinger independiente del tiempo.

Este potencial es interesante porque, a diferencia de otros modelos con soluciones anal√≠ticas, su tratamiento suele requerir m√©todos num√©ricos. La funci√≥n de onda $\psi(x)$ t√≠picamente se encuentra confinada en una regi√≥n finita y decrece r√°pidamente fuera de los l√≠mites definidos por la energ√≠a m√°xima $E_m$.

## Representaci√≥n gr√°fica
En la representaci√≥n gr√°fica del potencial en forma de V, se observa que:
- Para $x = 0$, el potencial es cero.
- A medida que $x$ se aleja del origen, el potencial crece proporcionalmente a $|x|$.
- Si se imponen barreras de potencial infinito en $x_0$ y $x_{N+1}$, la funci√≥n de onda deber√° anularse en estos puntos, similar a una part√≠cula confinada en un pozo de potencial.

Este modelo sirve como un buen ejercicio para estudiar m√©todos num√©ricos aplicados a problemas f√≠sicos y para comprender el comportamiento de sistemas cu√°nticos en potenciales no triviales.

# C√°lculo para los niveles de energ√≠a de la mol√©cula de hidr√≥geno üé†

# Resoluci√≥n de la ecuaci√≥n radial de Schr√∂dinger para H‚ÇÇ üëë

Referencia:

a. https://claude.ai/share/7950693a-1014-41be-9f29-f3f65bc06be7

b. Metodo de Numerov para el Calculo de Niveles de
Energƒ±a de la Molecula de Hidrogeno

## 1. Marco te√≥rico ‚ú®

La ecuaci√≥n de Schr√∂dinger nuclear (Born‚ÄìOppenheimer) es:

$$
\hat H_N = -\frac{\hbar^2}{2\mu}\nabla^2 + U(r).
$$

En coordenadas esf√©ricas y separando la parte angular:

$$
-\frac{\hbar^2}{2\mu}\left[ \frac{d^2R}{dr^2} + \frac{2}{r}\frac{dR}{dr}
- \frac{l(l+1)}{r^2}R \right] + U(r)R = ER.
$$

Con el cambio \(u(r) = rR(r)\):

$$
-\frac{\hbar^2}{2\mu}\frac{d^2u}{dr^2} + U_{\text{eff}}(r)u(r) = Eu(r),
$$

donde

$$
U_{\text{eff}}(r) = U(r) + \frac{\hbar^2 l(l+1)}{2\mu r^2}.
$$

---

## 2. Potenciales moleculares üéÅ

- **Morse** (H‚ÇÇ):
$$
U(r) = D_e \left(1 - e^{-\alpha(r-r_e)}\right)^2 - D_e
$$

- **Lennard‚ÄìJones**:
$$
U(r) = 4\epsilon\left[ \left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^6 \right]
$$

---

## 3. M√©todo de Numerov üéç

Se discretiza la ecuaci√≥n en una malla radial y se integra con condiciones de frontera:
- $(u(0)=0)$,
- $(u(r)\propto r^{l+1})$ para $(r\to 0)$.

Los niveles de energ√≠a se encuentran buscando ra√≠ces de la condici√≥n $(u(r_{\max})=0)$, usando el m√©todo de Brent (`brentq`).
"""

import numpy as np
import matplotlib.pyplot as plt
from ipywidgets import interact, FloatSlider, IntSlider
from scipy.optimize import brentq
import warnings
warnings.filterwarnings('ignore')

def numerov_step(psi_n, psi_nm1, k_n, k_nm1, k_np1, dx):
    """Un paso del m√©todo de Numerov"""
    factor = (2 * (1 - (5/12) * dx**2 * k_n) * psi_n - (1 + (1/12) * dx**2 * k_nm1) * psi_nm1) \
             / (1 + (1/12) * dx**2 * k_np1)
    return factor

def V_eff(r, U_r, l, mu, hbar):
    """Potencial efectivo incluyendo t√©rmino centr√≠fugo"""
    # Evitar divisi√≥n por cero en r=0
    cf = np.zeros_like(r)
    mask = r > 1e-15  # crea una m√°scara booleana que es true para elementos mayores a ese valor.
    cf[mask] = (hbar ** 2) * l * (l+1) / (2 * mu * r[mask] ** 2) # C√°lculo del potencial centr√≠fugo.
    return U_r + cf

def morse_potential(r, De, re, alpha):
    """
    Potencial de Morse para H2
    De: Profundidad del pozo (J)
    re: Distancia de equilibrio (m)
    alpha: Par√°metro de anchura (m^-1)
    """
    return De * (1 - np.exp(-alpha * (r - re)))**2 - De

def lennard_jones_potential(r, epsilon, sigma):
    """
    Potencial de Lennard-Jones como alternativa
    epsilon: Profundidad del pozo (J)
    sigma: Distancia caracter√≠stica (m)
    """
    return 4 * epsilon * ((sigma/r)**12 - (sigma/r)**6)

def numerov_solve(E, r, dr, mu, hbar, U_r, l):
    """
    Resuelve la ecuaci√≥n de Schr√∂dinger radial usando el m√©todo de Numerov

    Par√°metros:
    - E: Energ√≠a
    - r: Array de posiciones radiales (cerca de 0)
    - dr: Espaciado de la malla
    - mu: Masa reducida
    - hbar: Constante de Planck reducida
    - U_r: Potencial internuclear
    - l: N√∫mero cu√°ntico de momento angular

    Retorna:
    - u: Funci√≥n de onda radial (R(r) = u(r)/r)
    """
    u = np.zeros(len(r))
     # Potencial efectivo con t√©rmino centr√≠fugo
    Veff = V_eff(r, U_r, l, mu, hbar)
    k2 = 2 * mu * (E - Veff) / hbar**2
    # Condiciones iniciales para la funci√≥n radial u(r) = r*R(r)
    u[0] = 0.0
    # Para r peque√±o, u(r) ~ r^(l+1)
    if l == 0:
        u[1] = r[1]  # Comportamiento lineal para s-orbitales
        """
        Esto era lo que realizaba el paper, ya que tomaba unicamente el caso radial apra cuando l==0
        """
    else:
        u[1] = r[1]**(l+1)  # Comportamiento r^(l+1) para l > 0

    # Integraci√≥n usando Numerov
    for i in range(1, len(r)-1):
        u[i+1] = numerov_step(u[i], u[i-1], k2[i], k2[i-1], k2[i+1], dr)

    return u

def boundary_condition(E, r, dr, mu, hbar, V, l):
    """
    Funci√≥n que eval√∫a la condici√≥n de frontera.
    Para estados ligados, u(r_max) debe tender a 0
    """
    psi = numerov_solve(E, r, dr, mu, hbar, V, l)
    return psi[-1]  # La funci√≥n de onda debe ser 0 en el extremo

def find_energy_levels(r, dr, mu, hbar, V, E_min, E_max, l, n_levels=10):
    """
    Encuentra los niveles de energ√≠a para un momento angular dado
    """
    energy_levels = []

    # Crear una grilla fina de energ√≠as para buscar cambios de signo
    E_search = np.linspace(E_min, E_max, 3000)
    boundary_vals = []

    print(f"Buscando niveles de energ√≠a para l = {l}...")

    for E in E_search:
        try:
            val = boundary_condition(E, r, dr, mu, hbar, V, l)
            boundary_vals.append(val)
        except:
            boundary_vals.append(np.nan)

    boundary_vals = np.array(boundary_vals)

    # Buscar cambios de signo (ra√≠ces)
    for i in range(len(boundary_vals)-1):
        if (not np.isnan(boundary_vals[i]) and not np.isnan(boundary_vals[i+1]) and
            boundary_vals[i] * boundary_vals[i+1] < 0):

            try:
                # Usar el m√©todo de Brent para encontrar la ra√≠z exacta
                E_level = brentq(lambda E: boundary_condition(E, r, dr, mu, hbar, V, l),
                               E_search[i], E_search[i+1], xtol=1e-12)
                energy_levels.append(E_level)

                if len(energy_levels) >= n_levels:
                    break

            except:
                continue

    return np.array(energy_levels)

# Par√°metros para H2
m_p = 1.67262e-27  # Masa del prot√≥n (kg)
mu_H2 = m_p / 2    # Masa reducida de H2 ‚âà m_p/2
hbar = 1.055e-34   # Constante de Planck reducida (J¬∑s)
eV_to_J = 1.602e-19  # Conversi√≥n eV a Joules

# Par√°metros del potencial de Morse para H2
De_eV = 4.75  # Energ√≠a de disociaci√≥n (eV)
De = De_eV * eV_to_J  # En Joules
re = 0.74e-10  # Distancia de equilibrio (m)
alpha = 1.94e10  # Par√°metro de anchura (m^-1)

# Malla radial (empezar cerca de 0, no en 0)
r_max = 5e-10  # 5 Angstroms
N = 2001
r = np.linspace(0.01e-10, r_max, N)  # Empezar en 0.01 Angstrom
dr = r[1] - r[0]

def update_plot(l_quantum, E_min_eV, E_max_eV, potential_type):
    """Actualiza el plot con los par√°metros dados"""

    E_min = E_min_eV * eV_to_J
    E_max = E_max_eV * eV_to_J

    # Seleccionar tipo de potencial
    if potential_type == "Morse":
        V = morse_potential(r, De, re, alpha)
    else:  # Lennard-Jones
        epsilon = De  # Usar la misma profundidad
        sigma = re    # Usar la misma distancia caracter√≠stica
        V = lennard_jones_potential(r, epsilon, sigma)

    # Encontrar niveles de energ√≠a para el momento angular dado
    energy_levels = find_energy_levels(r, dr, mu_H2, hbar, V, E_min, E_max, l_quantum, n_levels=8)

    print(f"\nNiveles de energ√≠a encontrados para l = {l_quantum}: {len(energy_levels)}")
    for i, E in enumerate(energy_levels):
        # N√∫mero cu√°ntico vibracional v
        v = i
        print(f"v = {v}, l = {l_quantum}: E = {E/eV_to_J:.3f} eV")

    plt.figure(figsize=(12, 8))

    # Convertir a unidades de visualizaci√≥n
    r_plot = r / 1e-10  # En Angstroms
    V_plot = V / eV_to_J  # En eV

    # Plot del potencial
    plt.plot(r_plot, V_plot, 'r-', linewidth=3, label=f'V(r) - {potential_type}')

    colors = ['blue', 'green', 'orange', 'purple', 'brown', 'pink', 'gray', 'olive']

    # Plot de los niveles de energ√≠a y funciones de onda
    for i, E in enumerate(energy_levels[:8]):
        E_plot = E / eV_to_J  # En eV

        # Resolver para esta energ√≠a espec√≠fica
        u = numerov_solve(E, r, dr, mu_H2, hbar, V, l_quantum)

        # La funci√≥n de onda radial es R(r) = u(r)/r
        R = np.zeros_like(u)
        mask = r > 0
        R[mask] = u[mask] / r[mask]

        # Normalizar y escalar para visualizaci√≥n
        if np.max(np.abs(R)) > 0:
            R_norm = R / np.max(np.abs(R))
            R_scaled = R_norm * 0.5 + E_plot
        else:
            R_scaled = np.zeros_like(R) + E_plot

        color = colors[i] if i < len(colors) else 'black'

        # L√≠nea de energ√≠a
        plt.axhline(y=E_plot, color=color, linestyle='--', linewidth=1, alpha=0.7)

        # Funci√≥n de onda
        plt.plot(r_plot, R_scaled, color=color, linewidth=2,
                label=f'v={i}, l={l_quantum}')

        # Etiqueta de energ√≠a
        plt.text(r_plot[-1] + 0.1, E_plot, f'{E_plot:.2f} eV',
                fontsize=9, verticalalignment='center', color=color)

    plt.xlim(0, r_plot[-1] + 0.5)
    plt.ylim(-5, 2)
    plt.xlabel('r (√Ö)', fontsize=12)
    plt.ylabel('Energ√≠a (eV)', fontsize=12)
    plt.title(f'Niveles vibracionales de H‚ÇÇ (l = {l_quantum}) - {potential_type}',
              fontsize=14, pad=20)

    plt.grid(True, alpha=0.3)
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plt.show()

# Funci√≥n adicional para buscar un nivel espec√≠fico
def find_single_vibrational_level(r, dr, mu, hbar, V, l, E_guess_min, E_guess_max):
    """
    Encuentra un nivel vibracional espec√≠fico usando brentq
    """
    try:
        def f(E):
            return boundary_condition(E, r, dr, mu, hbar, V, l)

        E_level = brentq(f, E_guess_min, E_guess_max, xtol=1e-12)
        return E_level
    except ValueError as e:
        print(f"Error: No se encontr√≥ nivel en el intervalo dado. {e}")
        return None

# Widgets interactivos
interact(update_plot,
         l_quantum=IntSlider(value=0, min=0, max=5, step=1,
                           description='l (momento angular):'),
         E_min_eV=FloatSlider(value=-4.5, min=-5.0, max=0, step=0.1,
                            description='E_min (eV):'),
         E_max_eV=FloatSlider(value=0, min=-1, max=2, step=0.1,
                            description='E_max (eV):'),
         potential_type=['Morse', 'Lennard-Jones'])

print("Par√°metros de H‚ÇÇ:")
print(f"Masa reducida: {mu_H2/m_p:.3f} m_p")
print(f"Distancia de equilibrio: {re*1e10:.2f} √Ö")
print(f"Energ√≠a de disociaci√≥n: {De_eV:.2f} eV")
print(f"Punto cero vibracional estimado: {0.5 * hbar * np.sqrt(2*alpha**2 * De / mu_H2) / eV_to_J:.3f} eV")

