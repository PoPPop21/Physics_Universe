# -*- coding: utf-8 -*-
"""Euler_Method.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I-f4Uxzx-oK9L56fAWmcCVfLOoRqeibO

# M√©todo de eulerüå∑
### Tarea:
La tarea es que grafiques para el problema de decaimiento nuclear la soluci√≥n anal√≠tica, Euler expl√≠cito e impl√≠cito en un solo gr√°fico. As√≠ mismo el an√°lisis de errores entre ellos y hacer otro gr√°fico con el error global variando el paso, o sea, a medidas que vayas variando el paso poder ver si cambia¬†o¬†no¬†el¬†error

## ¬øEn que consiste este m√©todo?üíê

1. Euler expl√≠cito - m√©todo inestable
$$
y_{n+1} = y_{n} + hf(t_{n},y_{n}) = y_{n} - h \lambda y_{n} = (1 - h \lambda) y_{n}
$$

2. Euler √≠mplicito - m√©todo estable
$$
y_{n+1} = y_{n} + hf(t_{n+1},y_{n+1}) \\ y_{n+1} = y_{n} - h \lambda y_{n+1} \\ y_{n+1} = \frac{y_{n}}{1+h\lambda}
$$

## Dominios de estabilidad

# Decaimiento nuclear üîÆ
Se modela con la ecuacion diferencial:
$$
\frac{dy}{dt} = -\lambda y \\ y(0) = y_{0}
$$
donde
$$
 y(t) \text{: es el n√∫mero de n√∫cleos.} \\  \lambda > 0  \text{: es la constante de decaimiento.}
$$
La soluci√≥n anal√≠tica es:
$$
y(t) = y_{0} e^{-\lambda t}
$$
"""

import numpy as np
import matplotlib.pyplot as plt
import ipywidgets as widgets
from ipywidgets import interact

def simulacion(lam=1.0, y0=1.0, T=5.0, N=50, h=0.8):
  t = np.linspace(0, T, N+1) #arreglo de tiempos desde cero hasta T

  # --- Soluci√≥n anal√≠tica üéÄ ---
  y_exact = y0 * np.exp(-lam * t)

  # --- Euler expl√≠cito üéÄ ---
  y_exp = np.zeros(N + 1)
  y_exp[0] = y0 # array vac√≠o
  for n in range(N):
      y_exp[n + 1] = y_exp[n] * (1 - h * lam) # f√≥rmula iterativa de euler

  # --- Euler impl√≠cito üéÄ ---
  y_imp = np.zeros(N+1)
  y_imp[0] = y0 # otra vez un array vac√≠o
  for n in range(N):
      y_imp[n+1] = y_imp[n] / (1 + h*lam) # f√≥rmula iterativa

  # --- Gr√°fico üéÄ ---
  plt.figure(figsize=(8,5))
  plt.plot(t, y_exact, 'k-', label='Anal√≠tica')
  plt.plot(t, y_exp, 'r--', label='Euler Expl√≠cito')
  plt.plot(t, y_imp, 'b-.', label='Euler Impl√≠cito')
  plt.xlabel("t")
  plt.ylabel("y(t)")
  plt.title("Decaimiento nuclear")
  plt.legend()
  plt.grid()
  plt.show()

  # --- An√°lsiis de errores üéÄ ---
  error_exp = np.abs(y_exact - y_exp)# explc√≠cito
  error_imp = np.abs(y_exact - y_imp) # implicito

  plt.figure(figsize=(8,5))
  plt.plot(t, error_exp, 'r--', label='Error Euler Expl√≠cito')
  plt.plot(t, error_imp, 'b-.', label='Error Euler Impl√≠cito')
  plt.xlabel("t")
  plt.ylabel("Error absoluto")
  plt.title("Errores")
  plt.legend()
  plt.grid()
  plt.show()

# --- Widgets üéÄ ---
interact(simulacion,
         lam=widgets.FloatSlider(value=1.0, min=0.1, max=2.5, step=0.1, description='Œª'),
         y0=widgets.FloatSlider(value=1.0, min=0.1, max=2.0, step=0.1, description='y0'),
         T=widgets.FloatSlider(value=5.0, min=1.0, max=10.0, step=0.1, description='T'),
         N=widgets.IntSlider(value=50, min=10, max=100, step=10, description='N'),
         h=widgets.FloatSlider(value=0.8, min=0.0, max=0.8, step=0.01, description='h')
)

# --- Error global üéÄ ---
def error_global(lam=1.0, y0=1.0, T=5.0, Nmax=200):
    steps = np.linspace(10, Nmax, 10, dtype=int)  # 10 valores entre 10 y Nmax
    errors_exp, errors_imp, hs = [], [], []

    for N in steps:
        h = T / N
        t_temp = np.linspace(0, T, N+1)
        y_exact_temp = y0 * np.exp(-lam * t_temp)

        # Euler expl√≠cito
        y_e = np.zeros(N+1)
        y_e[0] = y0
        for n in range(N):
            y_e[n+1] = y_e[n] * (1 - h*lam)
        errors_exp.append(np.max(np.abs(y_exact_temp - y_e)))

        # Euler impl√≠cito
        y_i = np.zeros(N+1)
        y_i[0] = y0
        for n in range(N):
            y_i[n+1] = y_i[n] / (1 + h*lam)
        errors_imp.append(np.max(np.abs(y_exact_temp - y_i)))

        hs.append(h)

    # Gr√°fico log-log de error global
    plt.figure(figsize=(8,5))
    plt.loglog(hs, errors_exp, 'ro-', label='Euler Expl√≠cito')
    plt.loglog(hs, errors_imp, 'bo-', label='Euler Impl√≠cito')
    plt.xlabel("Tama√±o de paso h")
    plt.ylabel("Error global (norma infinito)")
    plt.title("Error global vs tama√±o de paso")
    plt.legend()
    plt.grid(True, which="both")
    plt.show()


# Widgets interactivos
interact(
    error_global,
    lam=widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description="Œª"),
    y0=widgets.FloatSlider(value=1.0, min=0.5, max=5.0, step=0.5, description="y‚ÇÄ"),
    T=widgets.FloatSlider(value=5.0, min=1.0, max=10.0, step=0.5, description="Tiempo T"),
    Nmax=widgets.IntSlider(value=200, min=50, max=1000, step=50, description="N m√°ximo")
)

"""# Estabilidad n√∫merica del m√©todo üéÄ

1. **M√©todo estable:** errores peque√±os de entrada sean errores peque√±os de salida.
2. **M√©todo inestable:** errores peque√±os (in) errores gandes (out).

---

## Decaimiento
La f√≥rmula para euler forward:

$$
N_{i+1} = N_{i} - h \alpha N_{i}
$$
 *Ejemplo*
$$
N_{3} = N_{2} - h \alpha N_{2} \\ N_{2} = N_{1} - h \alpha N_{1} \\ N_{1} = N_{0} - h \alpha N_{0} \\ \text{entonces} \\ N_{2} = (1 - h \alpha)^{2} N_{0} \\ N_{n} = (1 - \alpha)^{n} N_{0}
$$

si $ n ‚Üí ‚àû $ entonces $ ( 1 - \alpha)^{n} ‚Üí ‚àû $

---

### Para cualquier EDO:

$$
\frac{dy}{dx} = \lambda y \\ \text{si} \\ \lambda = \lambda_{r} + i \lambda_{i} \\ |1 + \lambda dt| \\ \text{de manera que} \\ \int \frac{dy}{y} = \int \lambda dt \\ \ln{y} = \lambda t \\ y = e^{\lambda t}
$$

entonces el m√©todo de euelr ser√≠a:
 $$
  y_{i+1} = (1 + e^{\lambda t}) \\ \sqrt{(1 + \lambda_{r}dt)^{2} + (\lambda_{i}dt)^{2} } < 1
 $$
"""

